[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18373462&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software Engineering refers to a process in which experts design, develop, test and maintain software. The industry is organized in a systematic approach to produce high-quality, reliable, and easy to maintain software applications. 
Software engineering is important in the technology industry as it ensures that software is created efficiently, functions properly, and can be easily updated or improved. The discipline is important in the following ways:
Quality and Reliability: Through software engineering, developers are able to create reliable and bug-free software. Such a product presents good functionality and fewer problems to the users.
Scalability and Maintenance: This quality means that software can develop and when need arises can be improved on with new features added without causing problems.
Efficiency: Software engineers can deploy structured methods and tools to develop software faster and cost effectively, enabling firms to release products quickly.
Security: The industry also seeks to create secure systems to safeguard against cyber threats, and free users data from intrusion.
Collaboration:Software should always meet business goals of a company developing it and ultimately the goals of the users. The synergy of the developers, testers, and business teams is required to achieve these goals.
Innovation and Competition: In a rapidly evolving tech world, companies constantly seek to innovate new software to help them stay competitive.

Identify and describe at least three key milestones in the evolution of software engineering.

Several key milestones have shaped the way software is developed today. We discuss three important ones:
The Development of Structured Programming (1960s-1970s): 
In its earlier years,software development was disorganised with no clear structures. This posed difficulties in developing programs culminating in the creation of software that was hard to debug and maintain. 
The structured programming principles of the 1960s and 1970s were introduced by Edsger Dijkstra, among other key figures. These principles pushed for  clear, linear flow in programs using loops, conditionals, and subroutines. This milestone is credited with the development of more predictable, easier to follow, and maintainable software.
The Introduction of Software Development Life Cycle (SDLC) Models (1980s): 
The Software Development Life Cycle (SDLC) of the 1980s introduced structured steps namely: requirements gathering, design, implementation, testing, and maintenance. This organized approach to software development enabled companies to enhance quality and achieve cost efficiency in their work. A good example of SDLC is the Waterfall model, which emphasized on  linear, methodical approach.
The Agile Revolution (2000s):
This revolution was occasioned by the limitations of previous software development models as the users' needs changed. Agile software development came up as a solution. It emphasised on a flexible and iterative progress, marked by close collaboration between developers and stakeholders. The 2001 Agile Manifesto outlined the principles to follow: valuing customer collaboration over contract negotiation and responding to change over following a strict plan. The revolution  is credited with the development of faster and more adaptable software development practices, and is in use to date.

List and briefly explain the phases of the Software Development Life Cycle.

The Software Development Life Cycle (SDLC) is a process where experts develop software in an organized and efficient way to ensure it is reliable and works properly for the users. It has several important stages:
Requirement Gathering and Analysis:
The first stage in this cycle entails establishing the needs of the people who will use the software. The goal is to clearly know the purpose of the software to be created. Developers do this by talking to the target people, asking them questions and looking at their businesses operations.
System Design:
This is the planning stage where developers figure out how the software will look and how it will work. They decide the software’s design, how the information will be stored, and how the user will interact with it.
Implementation (Coding):
The actual work of creating the software or coding gets  underway. Software engineers write the code to create the software while guided by the plan made in the design stage.
Testing:
This is a crucial step which helps to find and fix any problems or mistakes in the software before it’s used by people. Testing ensures the software works as planned.
Deployment:
After testing that that software works as expected the next step is to put it into use. The software  is installed and set up for the end users. They are also trained on how to use it.
Maintenance:
While in use software may need periodical updates or fixing to ensure to works well or to solve any new problems that might arise.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Waterfall Methodology
It refers to a traditional approach to software development. It follows a step-by-step process, where each stage must be completed before moving on to the next. The term alludes to a waterfall where water flows down in one direction from upper to lower grounds..
Waterfall methodology has a life cycle spanning: planning, designing, implementation, testing, and deployment.
It can be used in a wide range of works such as in a school library management system..Waterfall is a good approach when the requirements are clear from the start and one doesn't expect much change.

Pros of Waterfall:
Clear, well-defined steps.
Works well for projects with fixed requirements.
Easier to manage for smaller projects.
Cons of Waterfall:
If there’s a mistake in one step, it can be hard to fix later.
Doesn’t handle changes well during development.

Agile Methodology
It is a more flexible approach. It breaks the development process into small parts called sprints. Each sprint involves planning, designing, building, and testing a small piece of the software. After each sprint, one can review the work done, get feedback, and adjust the next steps.
How it works:
Planning: You plan small, manageable pieces of the software.
Design & Development: You work on one small part, design it, build it, and test it.
Review & Feedback: After each sprint, you show the work to the users and get feedback.
Repeat: You repeat the process until the software is complete.
Example of when to use Agile:
Assume a developer is building a mobile app for a college society. Since he might not be sure what the students want, can begin by creating a simple app with basic features like event reminders. After getting feedback, he can improve it, adding new features like notifications or a chat function in the next sprint. 
Pros of Agile:
Flexible and can easily adapt to changes.
Frequent feedback helps ensure the software meets the user’s needs.
You can see results faster, as small parts are completed in each sprint.
Cons of Agile:
It can be hard to manage if the project is large.
Requires constant communication with the team and users.
The final product may not be clear from the start, making planning more difficult.

Contrast of Waterfall and Agile methodologies

Planning: Waterfall needs full planning upfront, while Agile plans in smaller steps.
Flexibility: Waterfall doesn't allow changes once you move forward, while Agile encourages changes and improvements throughout the project.
Speed: Agile is faster in showing results because it works on parts of the project one by one, while Waterfall takes longer since it only shows results at the end.

Comparison of Waterfall and Agile methodologies

Both methodologies aim to deliver a product or solution that meets customer needs and provides value.
They both  involve phases like planning, design, development, testing, and deployment.
Some organizations use hybrid models that combine elements of both Waterfall and Agile. For example they may use Waterfall for initial requirements gathering and overall project planning. Afterwards they use Agile for development and delivery in iterative cycles.
Both methodologies include testing as a critical component.

1. Software Developer

Also called a programmer or coder is the person responsible for writing the code that makes the software work. They take the ideas from the design stage and turn them into a working program.
Roles and Responsibilities:
They write the instructions (code) that tell the computer what to do.
They follow the designs made by the team to make sure the software works properly.
 If there’s a bug in the software, developers are responsible for finding and fixing it.
They work closely with other developers and team members to make sure everything fits together well.
They test the code to make sure it works before the Quality Assurance Engineer does their final testing.
An example of a software developer is a person who creates a school management system where students' data, grades and timetable can be entered and stored.

2. Quality Assurance (QA) Engineer
Refers to the expert who ensures the software works correctly and is free from bugs before it’s released to users. 
Roles and Responsibilities:
They test the software to find out if there are any bugs or problems that need fixing.
They create tests to check different parts of the software, making sure everything works as it should.
If they find any bugs or issues, they report them to the developers so that they can be fixed.
 After fixing bugs, QA Engineers check again to make sure the problem is solved and that no new problems have appeared.
Example:
For example in the school management system, this engineer would test the system by entering student data, checking if the grading system works, and making sure the timetable displays correctly to see if there are any issues.


3. Project Manager
The Project Manager (PM) is tasked with ensruing the whole team works together efficiently and that the project is completed on time and within budget. 
Roles and Responsibilities:
The Project Manager makes sure there’s a clear plan for the project, setting deadlines and deciding what tasks need to be done.
They organize the work and make sure everyone knows what they need to do. They help solve problems and keep the team on track.
The Project Manager checks if the work is being done on time and ensures the team is meeting goals.
They talk to people outside the team such as customers and company board members to give updates on the project’s progress and get feedback.
The PM makes sure the team is delivering good-quality work that meets the expectations of the client or users.

For example in the school management system, the Project Manager would make sure the project is completed on time, communicate with the school about what they need, and ensure that the team is working together effectively to deliver a high-quality product.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

1. Software Developer

Also called a programmer or coder is the person responsible for writing the code that makes the software work. They take the ideas from the design stage and turn them into a working program.
Roles and Responsibilities:
They write the instructions (code) that tell the computer what to do.
They follow the designs made by the team to make sure the software works properly.
 If there’s a bug in the software, developers are responsible for finding and fixing it.
They work closely with other developers and team members to make sure everything fits together well.
They test the code to make sure it works before the Quality Assurance Engineer does their final testing.
An example of a software developer is a person who creates a school management system where students' data, grades and timetable can be entered and stored.

2. Quality Assurance (QA) Engineer
Refers to the expert who ensures the software works correctly and is free from bugs before it’s released to users. 
Roles and Responsibilities:
They test the software to find out if there are any bugs or problems that need fixing.
They create tests to check different parts of the software, making sure everything works as it should.
If they find any bugs or issues, they report them to the developers so that they can be fixed.
 After fixing bugs, QA Engineers check again to make sure the problem is solved and that no new problems have appeared.
Example:
For example in the school management system, this engineer would test the system by entering student data, checking if the grading system works, and making sure the timetable displays correctly to see if there are any issues.


3. Project Manager
The Project Manager (PM) is tasked with ensruing the whole team works together efficiently and that the project is completed on time and within budget. 
Roles and Responsibilities:
The Project Manager makes sure there’s a clear plan for the project, setting deadlines and deciding what tasks need to be done.
They organize the work and make sure everyone knows what they need to do. They help solve problems and keep the team on track.
The Project Manager checks if the work is being done on time and ensures the team is meeting goals.
They talk to people outside the team such as customers and company board members to give updates on the project’s progress and get feedback.
The PM makes sure the team is delivering good-quality work that meets the expectations of the client or users.

For example in the school management system, the Project Manager would make sure the project is completed on time, communicate with the school about what they need, and ensure that the team is working together effectively to deliver a high-quality product.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

1. Integrated Development Environments (IDEs)
Refers to a software tool that developers use to write, test, and debug their code with ease.  It presents a one-stop platform with everything a developer needs to create software. IDEs are important in software development process in the following ways:
They provide a user-friendly environment where developers can write code quickly without worrying about small details such as formatting.
IDEs help developers find bugs and fix them easily by highlighting errors.
 Most IDEs come with built-in tools to ease work such as syntax highlighting, which shows keywords in different colors. Other tools are auto-completion, which suggests code as the developer types, and debuggers which help track down errors.
They automate many repetitive tasks like organizing files, making it faster and easier to write code.
They improve productivity by enabling developers to focus on writing good code and  solving problems, rather than worrying about technical issues.
Examples of IDEs:
Visual Studio Code: This is a popular, free IDE that developers use to write code in different programming languages like JavaScript, Python, and HTML.
Eclipse: This is commonly used for Java development. It provides features like debugging and compiling code, which makes coding easier.
PyCharm: A great IDE for Python developers. It helps with writing, testing, and debugging Python code.

2. Version Control Systems (VCS)
A Version Control System (VCS) is a tool that helps developers keep track of the changes they make to the code over time. It allows them to go back to earlier versions of the code, compare changes, and collaborate with other developers.
Importance of VCS:   


VCS keeps a history of all the changes made to the code. This means developers can look back at previous versions if something goes wrong or if they need to understand how a feature was built.
In a team, multiple developers might be working on the same project at the same time. VCS allows everyone to work on their part of the project without messing up other people’s work. It also helps merge changes from different developers.
 Without VCS, developers might lose their progress if their computer crashes. With VCS, all changes are saved in a central place, so nothing is lost.
If a developer makes a mistake, VCS allows them to easily go back to an earlier, correct version of the code.
They allow developers to work on new features in separate branches and later combine them when ready.
Examples of VCS:
Git: This popular system allows developers to work on different parts of a project in separate branches and then merge their work. It’s widely used in open-source projects and software companies.
GitHub: GitHub is a platform that uses Git. It allows developers to store their code online, collaborate with others, and share their work..
Bitbucket: Just  like GitHub, in this platform developers can store their Git repositories.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

One common challenge software engineers face is dealing with bugs and errors. Bugs are mistakes in the code that prevent the software from working as it should. Engineers use debugging tools that help identify errors quickly. Writing small tests before the final code can also help catch problems early. Additionally, it’s best to write code in small parts and test them one by one, making it easier to find bugs before they become bigger issues.
Another challenge is time management. Software projects can be large, and engineers often face strict deadlines, making it hard to manage time effectively. Breaking the work into smaller, manageable tasks helps track progress and meet deadlines. Tools like Trello or Jira can help engineers organize their work. 
Sometimes, understanding the client’s needs can be tricky. Clients may not always know exactly what they want, which can lead to confusion. To prevent this, software engineers must communicate clearly with clients, ask questions to clarify details, and ensure they understand the requirements. Writing everything down in a clear document that both the client and developer can refer to helps avoid misunderstandings later on.
Working in teams can also present challenges. Team members may have different ideas or work at different speeds, causing delays or confusion. Collaboration tools like GitHub or GitLab allow team members to work together without messing up each other’s work. Good communication and regular updates are essential to keep everyone on the same page.
Keeping up with new technologies can be difficult because technology is constantly changing. Software engineers need to keep learning new tools, programming languages, and methods. This can be overwhelming, but they can overcome it by dedicating time to learning outside of work through online tutorials and videos. Being part of developer communities, like Stack Overflow or GitHub, helps engineers stay updated and learn from others. 

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Unit Testing
Unit testing is when developers test individual parts or small units of the software, like a single function or a method, to make sure they work correctly.
It works by a developer checking a small piece of code in isolation to see if it behaves as expected. For example, testing a simple calculator function to ensure it adds numbers correctly.
Unit testing helps find and fix bugs early in the development process, making sure each part of the software works before it’s combined with the rest of the system. It saves time later because it’s easier to fix small problems early than bigger ones later.
Integration Testing
Integration testing happens when different parts of the software that were tested separately in unit testing are put together to make sure they work well together.
After unit testing, engineers test how different units of the software interact with each other. For example, if a student registration system has a "login" module and a "registration" module, integration testing would check if both modules work together properly when users try to log in and register at the same time.
Integration testing ensures that the individual parts of the software don’t just work on their own, but also work well together when combined. This helps prevent problems like data not being shared correctly between parts of the software.
System Testing
System testing involves testing the entire software system as a whole to make sure it behaves as expected in real-world condition
Here, engineers check if all the features of the software are working together as planned. For example, in a school management system, system testing would make sure that students can register, view their grades, and check timetables all within the same platform.
System testing is important in that it ensures the whole system works properly when everything is put together. It also checks for any major issues that might not have been caught in earlier testing phases, making sure that the software is ready for real use.
Acceptance Testing
Acceptance testing is done to make sure the software meets the requirements and needs of the users or the client. This is usually the final step before the software is released.
It works by the client or end-users testing the software to make sure it does what they expect it to do. For example, the school management system might be tested by school staff to check if it meets their needs, like making sure it handles grades, attendance, and timetables correctly.
This testing ensures that the software meets the expectations of the users and that they are happy with how it works. If any major issues are found, they can be fixed before the software is fully released to the public.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the process of carefully designing and crafting the instructions -prompts- you give to an AI model, like ChatGPT, in order to get the best possible response. It entails sking the right questions or giving clear directions to the AI to get accurate, helpful, and relevant answers.
For example, instead of asking an AI, "Tell me about livestock," you could ask, "What are the main differences between a cow and a sheep?" This specific prompt helps the AI give a more detailed and focused answer.

Importance of Prompt Engineering
Provides better responses: When you ask clear and specific questions, the AI is more likely to give you an answer that is useful and on point. If you don’t give a clear prompt, you might get a vague or off-topic response. For instance, iInstead of just asking, "What is the weather?" you could ask, "What is the weather in Nairobi tomorrow?" This helps the AI provide a more useful and accurate answer.
Saves time: A well-crafted prompt can save you time because the AI will give you a direct and useful answer. If the prompt is unclear, you might have to ask follow-up questions, wasting time.
Improves communication: When you interact with AI models, it's like talking to a computer that doesn’t have human instincts. By using proper prompt engineering, you make sure the AI understands exactly what you need. This helps in getting the right answer without misunderstanding.
When you need detailed or complex answers you can design the right prompt for more detailed explanations. For example you want to know how to solve a math problem, instead of saying, "How do I solve this?" you could say, "Can you explain step by step how to solve this quadratic equation?"
Avoiding errors: If you give a poorly worded prompt, the AI may misunderstand what you're asking, leading to errors. Proper prompt engineering helps reduce mistakes and ensures that you get the correct and reliable information.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague Prompt:
"Tell me about geography."
Improved Prompt:
"Can you explain the various geographical features prevalent in Rift Valley and North Eastern regions of Kenya?"

The improved prompt provides a more useful and accurate response in regards to the geography of the two regions.
